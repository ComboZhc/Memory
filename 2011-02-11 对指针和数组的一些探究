闲来无事，对C语言指针和数组进行了一些探究:

//main.c

#include <stdio.h>

 

#define PRINTINT(a) printf("%s : %x\n", #a, a)

//这里是用于输出表达式字符串及表达式字符串的16进制值

int main() {

extern char* bb;

char a[] = "World, Hello!";

const char *oh = "Hello";

char *pa = a;

int i = a;

int *pi = a;

PRINTINT(a[2]); //输出72

//最常规的引用

PRINTINT(2[a]); //输出72

//将数组名和下标倒过来

//推测正确的原因:

//编译器在编译时已经把数组名转换成内存的地址了, 这么引用其实类似于2[BX]的8086汇编写法

PRINTINT(pa[2]);//输出72

//常规引用

PRINTINT(2[pa]);//输出72

//这里输出结果于2[a]相同,但是原理是不一样的,稍后解释

//PRINTINT(&a); [ERROR!]

//推测正确的原因:

//由于编译器已经把数组名转换成地址, 比如0x00000072, 对这个地址(可以说是一个常数)是没有地址的,绕口= =

PRINTINT(&pa); //输出22fef0

//推测正确的原因:

//指针存储的内容是 指针所指内容的地址, 而这个指针在内存中有另一个地址的，也就是指针实际上

//占有4字节的内存空间.

//再解释前面pa[2]和a[2]的区别,(指针和数组的区别!)

//a[2]:

//将数组的地址与偏移量2相加，产生一个新地址

//访问内存中的新地址，取得字符

//pa[2]:

//访问符号表中pa的地址, 取得这里存储的指针(所指内容的地址)

//将这个地址与指针的值相加，产生一个新地址

//访问内存中的新地址，取得字符

//PRINTINT(bb[1]); [ERROR!]

//---------------------------bak.c----------------------------------

//char bb[10];

//---------------------------bak.c----------------------------------

//这就是为什么定义是数组,不能声明为指针的原因了[!!!]

//这里的bb的地址是bak.c中bb数组名代表的地址, 所以这里的bb的值就是bak.c中bb[0]的值

PRINTINT(2["Apple"]);//输出70

PRINTINT("Hello"[2]);//输出6c

//推测正确的原因:

//编译器把字符串存到常量存储区, 然后"hello"返回的是其地址...

PRINTINT(pi[1]); //输出48202c64,恰好是'H', ' ', ',', 'd'的ASCII值

PRINTINT(1[pi]); //输出48202c64

//只要是指针, 不管指向什么类型, 都能如此访问

//PRINTINT(i[3]); [ERROR!]

//PRINTINT(3[i]); [ERROR!]

//虽然存的是地址, 但是不是指针类型, 编译器不认账的.

PRINTINT("Hello"); //输出403024

PRINTINT(&"Hello"); //输出403024

PRINTINT(oh); //输出403024

PRINTINT(&oh); //输出22fef4

//推测这样的原因:

//大概对一个字符串常量取地址和对一个变量取地址是不一样的.

//发现头两行输出一样, 于是知道对字符串常量取地址和直接写字符串常量都是一样的,(?后面有解释) 都能取得其地址.

//PRINTINT(&(&("Hello"))); [ERROR!]

//对某地址取地址, 如同对某数组名取地址, 错误"

PRINTINT(*&("Hello"));//输出403024

//可见这里*也是做了一些无聊的工作

PRINTINT("Hello" + 2);//输出403026

PRINTINT(*("Hello" + 2));//输出6c

PRINTINT(*(&"Hello" + 2));//输出403030

PRINTINT(*(&"Hello" + 1));//输出40302a

//这里突然发现

//PRINTINT("Hello" + 2);//输出403026

//PRINTINT(*(&"Hello" + 2));//输出403030

//这两个输出不同，具体愿因见下面的探究

PRINTINT(sizeof(&"Hello"));//输出4

PRINTINT(sizeof("Hello"));//输出6

//推测正确的原因:

#include <stdio.h>

 

#define PRINTINT(a) printf("%s : %x\n", #a, a)

//这里是用于输出表达式字符串及表达式字符串的16进制值

int main() {

extern char* bb;

char a[] = "World, Hello!";

const char *oh = "Hello";

char *pa = a;

int i = a;

int *pi = a;

PRINTINT(a[2]); //输出72

//最常规的引用

PRINTINT(2[a]); //输出72

//将数组名和下标倒过来

//推测正确的原因:

//编译器在编译时已经把数组名转换成内存的地址了, 这么引用其实类似于2[BX]的8086汇编写法

PRINTINT(pa[2]);//输出72

//常规引用

PRINTINT(2[pa]);//输出72

//这里输出结果于2[a]相同,但是原理是不一样的,稍后解释

PRINTINT(&a);  //这里应该是正确的!22fef6

//推测正确的原因:

//编译器将数组名转换成指针

PRINTINT(&pa); //输出22fef0

//推测正确的原因:

//指针存储的内容是 指针所指内容的地址, 而这个指针在内存中有另一个地址的，也就是指针实际上

//占有4字节的内存空间.

//再解释前面pa[2]和a[2]的区别,(指针和数组的区别!)

//a[2]:

//将数组的地址与偏移量2相加，产生一个新地址

//访问内存中的新地址，取得字符

//pa[2]:

//访问符号表中pa的地址, 取得这里存储的指针(所指内容的地址)

//将这个地址与指针的值相加，产生一个新地址

//访问内存中的新地址，取得字符

//PRINTINT(bb[1]); [ERROR!]

//---------------------------bak.c----------------------------------

//char bb[10];

//---------------------------bak.c----------------------------------

//这就是为什么定义是数组,不能声明为指针的原因了[!!!]

//这里的bb的地址是bak.c中bb数组名代表的地址, 所以这里的bb的值就是bak.c中bb[0]的值

PRINTINT(2["Apple"]);//输出70

PRINTINT("Hello"[2]);//输出6c

//推测正确的原因:

//编译器把字符串存到常量存储区, 然后"hello"返回的是其地址...

PRINTINT(pi[1]); //输出48202c64,恰好是'H', ' ', ',', 'd'的ASCII值

PRINTINT(1[pi]); //输出48202c64

//只要是指针, 不管指向什么类型, 都能如此访问

//PRINTINT(i[3]); [ERROR!]

//PRINTINT(3[i]); [ERROR!]

//虽然存的是地址, 但是不是指针类型, 编译器不认账的.

PRINTINT("Hello"); //输出403024

PRINTINT(&"Hello"); //输出403024

PRINTINT(oh); //输出403024

PRINTINT(&oh); //输出22fef4

//推测这样的原因:

//大概对一个字符串常量取地址和对一个变量取地址是不一样的.

//发现头两行输出一样, 于是知道对字符串常量取地址和直接写字符串常量都是一样的,(?后面有解释) 都能取得其地址.

//PRINTINT(&(&("Hello"))); [ERROR!]

//对某地址取地址, 如同对某数组名取地址, 错误"

PRINTINT(*&("Hello"));//输出403024

//可见这里*也是做了一些无聊的工作

PRINTINT("Hello" + 2);//输出403026

PRINTINT(*("Hello" + 2));//输出6c

PRINTINT(*(&"Hello" + 2));//输出403030

PRINTINT(*(&"Hello" + 1));//输出40302a

//这里突然发现

PRINTINT("Hello" + 2);//输出403026

PRINTINT(*(&"Hello" + 2));//输出403030

//这两个输出不同，具体原因见下面的探究

PRINTINT(sizeof(&"Hello"));//输出4

PRINTINT(sizeof("Hello"));//输出6

//推测正确的原因:

//&"Hello"相当于一个标准的指针

//"Hello"返回的是地址,但并不相当于标准的指针.因为sizeof返回的结果是6,即'H','e','l','l','o','\0'的个数

return 0;

}

//本文对指针,数组和字符串常量进行了一些探究,原因均为自己推理,讹误之处烦请各位指正!

//&"Hello"相当于一个标准的指针

//"Hello"返回的是地址,但并不相当于标准的指针.因为sizeof返回的结果是6,即'H','e','l','l','o','\0'的个数

return 0;

}

//本文对指针,数组和字符串常量进行了一些探究,原因均为自己推理,讹误之处烦请各位指正!

//总结: 1.指针与数组是不一样的

          2.字符串常量存储在内存中

          3.指针的加减法根据其所值类型产生结果

          4.a[b]与*(a+b)与b[a]等价.（多谢lwc提醒)

